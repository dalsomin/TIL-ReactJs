### useMemo

1. memoization

   * 기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법을 말한다. memoization을 적절히 적용하면 중복 연산을 피할 수 있기 때문에 메모리를 조금더 쓰더라도 어플리케이션의 성능을 최적화 할 수 있다. 
   * 리액트에서는 랜더링마다 컴포넌트 함수가 호출되게 되는데 , 호출시 자바스크립트 로직들이 수행되고, 이를 기반으로 jsx로 마크업된 ui가 리턴되는 기본구조를 갖는게 리액트이다. 
   * 리액트에서 컴포넌트의 렌더링은 한번 일어나고 끝이 아니라 수시로 계속 일어날 수 있다. 대푲거인 예로 컴포넌트의 자신의 상태변경이 일어날 수 있고, 아니면 부모 컴포넌트의 상태변경이 일어나 덩달아 함께 렌더링이 될 수도 있다. 리액트에는 수동으로 다시 렌더링 해주는 api도 있고, 사용자가 브라우저를 새로고침할 시에도 컴포넌트는 리렌더링이 되버린다. 
   * 만약 함수형 컴포넌트가 내부적으로 매우 복잡한 연산을 수행한다면 몇초이상 오래걸리는 결과가 초래될 수도 있다. 컴포넌트의 리랜더링이 필요할 때마다 이함수가 호출이 되므로 사용자는 지속적으로ui에서 지연이 발생하는 경험을 하게 된다. 

2. 함수형 컴포넌트에 메모이제이션을 적용해보자.

   * 렌더링이 일어날때마다 함수의 인자로 넘어오는 매개변수값이 항상 바뀌는게 아니라면 굳이 함수를 계속 재호출할 필요가 있을까? 렌더링이 발생했을때 이전 렌더링과 현재 렌더링간에 매개변수값이 동일한 경우, 다시 동일한 함수를 호출하여 return값을 구하는 대신, 기존의 메모리 어딘가에 저장해 두었던 return값을 그대로 사용하는 것이다. 

   * memoization로직을 직접 구현할 수도 있겠지만, 대신에 간편하게 사용할 수 있는 것이 react의 useMemo 훅이다. 

   * useMemo함수는 2개의 인자를 받는데, 첫번째는 결과값을 생성해주는 팩토리 함수이고, 두번쨰는 기존 결과값 재활용여부의 기준이 되는 입력값 배열이다. 

   * ```jsx
     function MyComponent({ x, y }) {
       const z = useMemo(() => compute(x, y), [x, y])
       return <div>{z}</div>
     }
     ```

   * 이때 x,y값이 렌더링전과 값이 동일한 경우, 이전 렌더링떄 저장해두었던 결과값을 재활용한다. 하지만 xy값이 달라졌다면 `usememo()`안의` ()=>compute(x,y)`함수를 호출하여 새롭게 구한 값을 z로 전달한다. 

3. 주의 
   * 성능최적화를 할때는 대가가 따른다. 무분별하게 적용하는것을 유의해야한다. useMemo를 남용하게 되면 컴포넌트의 복잡도가 올라가기 떄문에 콛르르 읽기도 어려워지고 유지보수성도 떨어지게된다. useMemo가 적용된 레퍼런스는 재활용을 위해서 가비지 컬렉션에서 제외되기때문에 메모리를 더 쓰게 된다. 
   * 실제 useMemo를 적용하는 일은 생각보다 많지가 않다. 왜냐하면 수초이상 걸리는 로직이 프론트엔드에 존재한다는 것자체가 일반적인 앱에서는 흔치 않는 일이고, 설사 그렇게 오래걸린다해도 useEffect 를 이용해서 비동기로 처리하는 방안을 먼저 고려하게 되기 떄문이다. 따라서 useMemo가 빛을 발하는 상황은 극히 제한적이며, 브라우저에서 리액트가 실행되는 속도도 워낙 빠르다 보니, 왠만한 컴포넌트가 여러번 렌더링이 된다고해서 실제로 심각한 성능이슈가 되지 않는다. 