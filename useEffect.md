이번에는 useEffect 라는 Hook 을 사용하여 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 언마운트 됐을 때 (사라질 때), 그리고 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리하는 방법에 대해서 알아보자

1. 화면이 처음 떴을때 실행.
   - deps에 [] 빈배열을 넣을 떄.
   - life cycle중 componentDidmount처럼 실행
2. 화면이 사라질때 실행(clean up함수).
   - componentWillUnmount처럼 실행
3. deps에 넣은 파라미터값이 업데이트 됬을때 실행.
   - componentDidUpdate처럼 실행.

https://rinae.dev/posts/a-complete-guide-to-useeffect-ko
 useEffect는 동기화이다 ! 

>  참고로 리액트 컴포넌트는 기본적으로 부모컴포넌트가 리렌더링되면 자식 컴포넌트 또한 리렌더링이 됩니다. 바뀐 내용이 없다 할지라도요.

>  물론, 실제 DOM 에 변화가 반영되는 것은 바뀐 내용이 있는 컴포넌트에만 해당합니다. 하지만, Virtual DOM 에는 모든걸 다 렌더링하고 있다는 겁니다.


useEffect
비록 useEffect가  함수형 컴포넌트에서 정의한 각 생명주기 메서드 들에 일대일로 대응하는 것은 아니지만,  useEffect를 사용함으로서, 가독성을 높이면서도 (연관된 기능들끼리 한곳으로 모을 수 있기때문에 )가능해졌습니다. 
컴포넌트 내부에서 데이터를 가져오거나 구독(상태값이 변하는것을 감지)하고, DOM을 직접 조작하는 작업을 useEffect를 통해서 할 수 있습니다. 이런 동작들을 side effects라고 합니다. 왜냐하면 이러한 작업들은 다른 컴포넌트에 영향을 줄 수도 있고, 렌더링 과정에서는 구현할 수 없는 작업이기 떄문입니다. 
위 예시는 React가 DOM을 업데이트 한 뒤에 문서의 타이틀을 바꾸는 컴포넌트입니다. 
useEffect를 사용하면, React는 DOM을 바꾼 뒤에 useEffect함수를 실행 할 것입니다.즉, 렌더링이 될때마다 useEffect함수가 실행됩니다. 
이때에 useEffect함수를 해제할 필요가 있다면, 해제하는 함수를 반환해주면됩니다. 이는 선택적입니다.  Effects는 컴포넌트 안에 선언 되어 있기 때문에 props와 state에 접근할 수 있습니다. 
즉useEffect 훅에 입력된 함수는 렌더링 결과가 실제 돔에 반영된 후 호출되며, 구독을 해지하고 싶다면 해제하는 함수를 반환하고, 특정 state가 변경될때에만 함수가 호출되게 하고싶다면 useEffect의 두번째 매개변수에 배열안에 등록하면된다. 
이는 클래스형 컴포넌트의 componentDidmount와 componentDidUpdate 양쪽 메서드에 추가하면 같은 기능을 하게 될 것이다 .
 클래스형 컴포넌트의 componentDidMount메서드에서는 무언가를 등록하고 componentWillMount메서드에서는 무언가를 해제하는 코드가 자주 사용된다. 서로 다른 여러 로직이 하나의 생명주기 메서드에 추가되면서 코드는 복잡해지고 componentDidMount 메서드에서 등록했던 것을 componentWillUnMount메서드에서 해제하는 것을 깜박하는 경우가 종종발 생하게 되는데, 이때 useEffect훅을 이용하면 이러한 등록과, 해제 절차를 한 곳에서 관리 할 수 있다. 
아래 예시에서 컴포넌트가 unmount될 때 React는 ChatAPI에서 구독을 해지할 것이다. 또한 재 렌더링이 일어나 effect를 재실행하기 전에도 마찬가지로 구독을 해지하게됩니다. 만약 원한다면 porps.friend.id가 바뀌지 않았을때 재구독을 건너뛰도록 설정할 수 도 있습니다. 
재구독을 건너뛰는 방법은 두번째 매개변수로 특정값을 배열에 넣어 넘기면됩니다. 이는 특정값들이 리렌더링시에 변경되지 않는다면 리액트로 하여금 effect를 건너뛰도록 하는 것입니다. 

